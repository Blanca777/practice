<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。
      // 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
      // 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
      // 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

      // 1) 简单请求
      // 只要同时满足以下两大条件，就属于简单请求
      // 条件1：使用下列方法之一：

      // GET
      // HEAD
      // POST

      // 条件2：Content-Type 的值仅限于下列三者之一：

      // text/plain
      // multipart/form-data
      // application/x-www-form-urlencoded

      // 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。
      // 2) 复杂请求
      // 不符合以上条件的请求就肯定是复杂请求了。
      // 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

      // 作者：浪里行舟
      // 链接：https://juejin.cn/post/6844903767226351623
      // 来源：稀土掘金
      // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      let xhr = new XMLHttpRequest();
      document.cookie = "name=xiamen1"; // cookie不能跨域
      xhr.withCredentials = true; // 前端设置是否带cookie
      xhr.open("PUT", "http://localhost:4000/getData", true);
      xhr.setRequestHeader("name", "xiamen");
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
            console.log(xhr.response);
            //得到响应头，后台需设置Access-Control-Expose-Headers
            console.log(xhr.getResponseHeader("name"));
          }
        }
      };
      xhr.send();
    </script>
  </body>
</html>
